$date
	Sat Jun 01 20:29:54 2019
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module test $end
$var wire 32 ! writeData [31:0] $end
$var wire 26 " target [25:0] $end
$var wire 5 # rt [4:0] $end
$var wire 5 $ rs [4:0] $end
$var wire 32 % readData2 [31:0] $end
$var wire 32 & readData1 [31:0] $end
$var wire 5 ' rd [4:0] $end
$var wire 4 ( pc4 [3:0] $end
$var wire 6 ) opcode [5:0] $end
$var wire 1 * controland $end
$var wire 28 + addressShiftJ [27:0] $end
$var wire 32 , addressShift [31:0] $end
$var wire 32 - addressOut [31:0] $end
$var wire 32 . addressJ [31:0] $end
$var wire 32 / addressFinal [31:0] $end
$var wire 32 0 addressFin [31:0] $end
$var wire 32 1 address32 [31:0] $end
$var wire 16 2 address [15:0] $end
$var wire 1 3 Zero $end
$var wire 1 4 RegWrite $end
$var wire 32 5 RegMUXoutULA [31:0] $end
$var wire 5 6 RegMUXOut [4:0] $end
$var wire 1 7 RegDst $end
$var wire 32 8 ProxInstruction [31:0] $end
$var wire 1 9 MemtoReg $end
$var wire 1 : MemWrite $end
$var wire 1 ; MemRead $end
$var wire 1 < Jump $end
$var wire 32 = InstructionOut [31:0] $end
$var wire 6 > FuncCode [5:0] $end
$var wire 32 ? DataMemory [31:0] $end
$var wire 1 @ Branch $end
$var wire 1 A ALUSrc $end
$var wire 32 B ALUResultAdd [31:0] $end
$var wire 32 C ALUResult [31:0] $end
$var wire 2 D ALUOp [1:0] $end
$var wire 4 E ALUCtl [3:0] $end
$var reg 32 F addressIn [31:0] $end
$var reg 1 G clk $end
$scope module addula $end
$var wire 32 H addressSomador [31:0] $end
$var wire 32 I addressShift [31:0] $end
$var reg 32 J ALUResult [31:0] $end
$upscope $end
$scope module alu $end
$var wire 32 K value2 [31:0] $end
$var wire 32 L value1 [31:0] $end
$var wire 4 M ALUControl [3:0] $end
$var reg 32 N ALUResult [31:0] $end
$var reg 1 3 zero $end
$upscope $end
$scope module alucontrol $end
$var wire 6 O FuncCode [5:0] $end
$var wire 2 P ALUOp [1:0] $end
$var reg 4 Q ALUCtl [3:0] $end
$upscope $end
$scope module controlador $end
$var wire 6 R opcode [5:0] $end
$var reg 2 S ALUOp [1:0] $end
$var reg 1 A ALUSrc $end
$var reg 1 @ Branch $end
$var reg 1 < Jump $end
$var reg 1 ; MemRead $end
$var reg 1 : MemWrite $end
$var reg 1 9 MemtoReg $end
$var reg 1 7 RegDst $end
$var reg 1 4 RegWrite $end
$upscope $end
$scope module datamu $end
$var wire 32 T ALURst [31:0] $end
$var wire 1 9 MemtoReg $end
$var wire 32 U readDataMemory [31:0] $end
$var reg 32 V writeData [31:0] $end
$upscope $end
$scope module dbreg $end
$var wire 1 4 RegWrite $end
$var wire 32 W readData1 [31:0] $end
$var wire 32 X readData2 [31:0] $end
$var wire 5 Y rt [4:0] $end
$var wire 5 Z rs [4:0] $end
$var wire 5 [ rd [4:0] $end
$var wire 5 \ WriteRegister [4:0] $end
$upscope $end
$scope module deslocamento $end
$var wire 32 ] addressExtendido [31:0] $end
$var reg 32 ^ addressShift [31:0] $end
$upscope $end
$scope module desvio $end
$var wire 32 _ in1 [31:0] $end
$var wire 32 ` in0 [31:0] $end
$var wire 1 * controland $end
$var reg 32 a addressDesvio [31:0] $end
$upscope $end
$scope module dm $end
$var wire 1 ; MemRead $end
$var wire 1 : MemWrite $end
$var wire 32 b WriteData [31:0] $end
$var wire 32 c address [31:0] $end
$var wire 32 d DataMemory [31:0] $end
$upscope $end
$scope module extends $end
$var wire 32 e saida [31:0] $end
$var wire 16 f entrada [15:0] $end
$upscope $end
$scope module im $end
$var wire 32 g addressIn [31:0] $end
$var reg 32 h InstructionOut [31:0] $end
$var reg 32 i ProxInstruction [31:0] $end
$upscope $end
$scope module inst $end
$var wire 32 j addressIn [31:0] $end
$var wire 6 k opcode [5:0] $end
$var reg 6 l FuncCode [5:0] $end
$var reg 16 m address [15:0] $end
$var reg 5 n rd [4:0] $end
$var reg 5 o rs [4:0] $end
$var reg 5 p rt [4:0] $end
$upscope $end
$scope module jumpaddress $end
$var wire 32 q somador [31:0] $end
$var wire 28 r addressShiftJ [27:0] $end
$var reg 32 s addressJ [31:0] $end
$var reg 4 t pc4 [3:0] $end
$upscope $end
$scope module jumpmux $end
$var wire 1 < Jump $end
$var wire 32 u addressFin [31:0] $end
$var wire 32 v addressJ [31:0] $end
$var reg 32 w addressFinal [31:0] $end
$upscope $end
$scope module multplexador $end
$var wire 1 7 RegDst $end
$var wire 5 x rd [4:0] $end
$var wire 5 y rt [4:0] $end
$var reg 5 z RegMUXOut [4:0] $end
$upscope $end
$scope module muxula $end
$var wire 1 A ALUSrc $end
$var wire 32 { valueMux0 [31:0] $end
$var wire 32 | valueMux1 [31:0] $end
$var reg 32 } RegMUXoutULA [31:0] $end
$upscope $end
$scope module pc $end
$var wire 32 ~ addressInPC [31:0] $end
$var wire 1 G clk $end
$var reg 32 !" addressOut [31:0] $end
$upscope $end
$scope module portand $end
$var wire 1 @ Branch $end
$var wire 1 3 Zero $end
$var reg 1 * controland $end
$upscope $end
$scope module shtj $end
$var wire 32 "" inst [31:0] $end
$var wire 26 #" target [25:0] $end
$var reg 28 $" addressShiftJ [27:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b1000110010010000000010000000 $"
b10001100100100000000100000 #"
b10001100100100000000100000 ""
b0 !"
b0 ~
b10010 }
b100000000100000 |
b10010 {
b1000 z
b10010 y
b1000 x
bx w
b1000110010010000000010000000 v
b1000010011000000000100010 u
b0 t
b1000110010010000000010000000 s
b1000110010010000000010000000 r
b1000010011000000000100010 q
b10010 p
b10001 o
b1000 n
b100000000100000 m
b100000 l
b0 k
b10001100100100000000100000 j
b1000010011000000000100010 i
b10001100100100000000100000 h
b0 g
b100000000100000 f
b100000000100000 e
bx d
b100011 c
b10010 b
b1000010011000000000100010 a
b1000010011000000000100010 `
b1000010101000000010100010 _
b10000000010000000 ^
b100000000100000 ]
b1000 \
b1000 [
b10001 Z
b10010 Y
b10010 X
b10001 W
b0 V
bx U
b100011 T
b10 S
b0 R
b10 Q
b10 P
b100000 O
b100011 N
b10 M
b10001 L
b10010 K
b1000010101000000010100010 J
b10000000010000000 I
b1000010011000000000100010 H
0G
b0 F
b10 E
b10 D
b100011 C
b1000010101000000010100010 B
0A
0@
bx ?
b100000 >
b10001100100100000000100000 =
0<
0;
0:
09
b1000010011000000000100010 8
17
b1000 6
b10010 5
14
03
b100000000100000 2
b100000000100000 1
b1000010011000000000100010 0
bx /
b1000110010010000000010000000 .
b0 -
b10000000010000000 ,
b1000110010010000000010000000 +
0*
b0 )
b0 (
b1000 '
b10001 &
b10010 %
b10001 $
b10010 #
b10001100100100000000100000 "
b0 !
$end
#1
b1100000000010001000 ,
b1100000000010001000 I
b1100000000010001000 ^
b110 E
b110 M
b110 Q
b11111111111111111111111111110110 C
b11111111111111111111111111110110 N
b11111111111111111111111111110110 T
b11111111111111111111111111110110 c
b100001001100000000010001000 .
b100001001100000000010001000 s
b100001001100000000010001000 v
b1001100000100000010101101 B
b1001100000100000010101101 J
b1001100000100000010101101 _
b11000000000100010 1
b11000000000100010 ]
b11000000000100010 e
b11000000000100010 |
b1000000000100010 2
b1000000000100010 f
b1000000000100010 m
b100010 >
b100010 O
b100010 l
b10000 '
b10000 [
b10000 n
b10000 x
b1001 %
b1001 X
b1001 b
b1001 {
b1001 #
b1001 Y
b1001 p
b1001 y
b1000 &
b1000 L
b1000 W
b1000 $
b1000 Z
b1000 o
b100001001100000000010001000 +
b100001001100000000010001000 r
b100001001100000000010001000 $"
b1000010011000000000100010 "
b1000010011000000000100010 #"
b1001010100100000000100101 8
b1001010100100000000100101 H
b1001010100100000000100101 `
b1001010100100000000100101 i
b1001010100100000000100101 q
b1000010011000000000100010 =
b1000010011000000000100010 h
b1000010011000000000100010 j
b1000010011000000000100010 ""
b100 -
b100 g
b100 !"
b100 F
b100 ~
1G
#2
b100101010010000000010011100 .
b100101010010000000010011100 s
b100101010010000000010011100 v
b1000 (
b1000 t
b10000000010010100 ,
b10000000010010100 I
b10000000010010100 ^
b1 E
b1 M
b1 Q
b11011 C
b11011 N
b11011 T
b11011 c
b10001110011010010000000010011100 B
b10001110011010010000000010011100 J
b10001110011010010000000010011100 _
b100101010010000000010010100 +
b100101010010000000010010100 r
b100101010010000000010010100 $"
b100000000100101 1
b100000000100101 ]
b100000000100101 e
b100000000100101 |
b100000000100101 2
b100000000100101 f
b100000000100101 m
b100101 >
b100101 O
b100101 l
b1000 '
b1000 [
b1000 n
b1000 x
b1010 %
b1010 X
b1010 b
b1010 {
b1010 #
b1010 Y
b1010 p
b1010 y
b1001 &
b1001 L
b1001 W
b1001 $
b1001 Z
b1001 o
b1001010100100000000100101 "
b1001010100100000000100101 #"
b10001110011010000000000000001000 8
b10001110011010000000000000001000 H
b10001110011010000000000000001000 `
b10001110011010000000000000001000 i
b10001110011010000000000000001000 q
b1001010100100000000100101 =
b1001010100100000000100101 h
b1001010100100000000100101 j
b1001010100100000000100101 ""
b1000 -
b1000 g
b1000 !"
b1000 F
b1000 ~
0G
#3
b1000 5
b1000 K
b1000 }
bx !
bx V
b100000 ,
b100000 I
b100000 ^
b10 E
b10 M
b10 Q
b11011 C
b11011 N
b11011 T
b11011 c
b1001101000000000000000100000 .
b1001101000000000000000100000 s
b1001101000000000000000100000 v
b0 (
b0 t
b0 D
b0 P
b0 S
1A
19
1;
07
b1001010100100000001000100 B
b1001010100100000001000100 J
b1001010100100000001000100 _
b1000 1
b1000 ]
b1000 e
b1000 |
b1000 2
b1000 f
b1000 m
b1000 >
b1000 O
b1000 l
b0 '
b0 [
b0 n
b0 x
b1000 %
b1000 X
b1000 b
b1000 {
b1000 #
b1000 Y
b1000 p
b1000 y
b10011 &
b10011 L
b10011 W
b10011 $
b10011 Z
b10011 o
b1001101000000000000000100000 +
b1001101000000000000000100000 r
b1001101000000000000000100000 $"
b100011 )
b100011 R
b100011 k
b10011010000000000000001000 "
b10011010000000000000001000 #"
b1001010100100000000100100 8
b1001010100100000000100100 H
b1001010100100000000100100 `
b1001010100100000000100100 i
b1001010100100000000100100 q
b10001110011010000000000000001000 =
b10001110011010000000000000001000 h
b10001110011010000000000000001000 j
b10001110011010000000000000001000 ""
b1100 -
b1100 g
b1100 !"
b1100 F
b1100 ~
1G
#4
b1010 5
b1010 K
b1010 }
b10001 !
b10001 V
b100101010010000000010011010 .
b100101010010000000010011010 s
b100101010010000000010011010 v
b1010 (
b1010 t
b10000000010010000 ,
b10000000010010000 I
b10000000010010000 ^
b0 E
b0 M
b0 Q
b1000 C
b1000 N
b1000 T
b1000 c
b10 D
b10 P
b10 S
0A
09
0;
17
b10101110011010010000000011000000 B
b10101110011010010000000011000000 J
b10101110011010010000000011000000 _
b100101010010000000010010000 +
b100101010010000000010010000 r
b100101010010000000010010000 $"
b100000000100100 1
b100000000100100 ]
b100000000100100 e
b100000000100100 |
b100000000100100 2
b100000000100100 f
b100000000100100 m
b100100 >
b100100 O
b100100 l
b1000 '
b1000 [
b1000 n
b1000 x
b1010 %
b1010 X
b1010 b
b1010 {
b1010 #
b1010 Y
b1010 p
b1010 y
b1001 &
b1001 L
b1001 W
b1001 $
b1001 Z
b1001 o
b0 )
b0 R
b0 k
b1001010100100000000100100 "
b1001010100100000000100100 #"
b10101110011010000000000000110000 8
b10101110011010000000000000110000 H
b10101110011010000000000000110000 `
b10101110011010000000000000110000 i
b10101110011010000000000000110000 q
b1001010100100000000100100 =
b1001010100100000000100100 h
b1001010100100000000100100 j
b1001010100100000000100100 ""
b10000 -
b10000 g
b10000 !"
b10000 F
b10000 ~
0G
#5
b110000 5
b110000 K
b110000 }
b1000 ?
b1000 U
b1000 d
b11000000 ,
b11000000 I
b11000000 ^
b10 E
b10 M
b10 Q
b1000011 C
b1000011 N
b1000011 T
b1000011 c
b1001101000000000000011000001 .
b1001101000000000000011000001 s
b1001101000000000000011000001 v
b1 (
b1 t
b0 D
b0 P
b0 S
04
1A
1:
07
b10010001100010000000011000001 B
b10010001100010000000011000001 J
b10010001100010000000011000001 _
b110000 1
b110000 ]
b110000 e
b110000 |
b110000 2
b110000 f
b110000 m
b110000 >
b110000 O
b110000 l
b0 '
b0 [
b0 n
b0 x
b1000 %
b1000 X
b1000 b
b1000 {
b1000 #
b1000 Y
b1000 p
b1000 y
b10011 &
b10011 L
b10011 W
b10011 $
b10011 Z
b10011 o
b1001101000000000000011000000 +
b1001101000000000000011000000 r
b1001101000000000000011000000 $"
b101011 )
b101011 R
b101011 k
b10011010000000000000110000 "
b10011010000000000000110000 #"
b10010001100010000000000000001 8
b10010001100010000000000000001 H
b10010001100010000000000000001 `
b10010001100010000000000000001 i
b10010001100010000000000000001 q
b10101110011010000000000000110000 =
b10101110011010000000000000110000 h
b10101110011010000000000000110000 j
b10101110011010000000000000110000 ""
b10100 -
b10100 g
b10100 !"
b10100 F
b10100 ~
1G
#6
b1000000000000000000000001100 0
b1000000000000000000000001100 a
b1000000000000000000000001100 u
1*
13
b10001 5
b10001 K
b10001 }
b1000110001000000000000000100 .
b1000110001000000000000000100 s
b1000110001000000000000000100 v
b0 (
b0 t
b100 ,
b100 I
b100 ^
b110 E
b110 M
b110 Q
bx ?
bx U
bx d
b0 C
b0 N
b0 T
b0 c
b1 D
b1 P
b1 S
0A
0:
1@
b1000000000000000000000001100 B
b1000000000000000000000001100 J
b1000000000000000000000001100 _
b1000110001000000000000000100 +
b1000110001000000000000000100 r
b1000110001000000000000000100 $"
b1 1
b1 ]
b1 e
b1 |
b1 2
b1 f
b1 m
b1 >
b1 O
b1 l
b10001 %
b10001 X
b10001 b
b10001 {
b10001 #
b10001 Y
b10001 p
b10001 y
b10001 &
b10001 L
b10001 W
b10001 $
b10001 Z
b10001 o
b100 )
b100 R
b100 k
b10001100010000000000000001 "
b10001100010000000000000001 #"
b1000000000000000000000001000 8
b1000000000000000000000001000 H
b1000000000000000000000001000 `
b1000000000000000000000001000 i
b1000000000000000000000001000 q
b10010001100010000000000000001 =
b10010001100010000000000000001 h
b10010001100010000000000000001 j
b10010001100010000000000000001 ""
b11000 -
b11000 g
b11000 !"
b11000 F
b11000 ~
0G
#7
b10011101000100000000101010 0
b10011101000100000000101010 a
b10011101000100000000101010 u
03
b100000 /
b100000 w
0*
b100000 ,
b100000 I
b100000 ^
b11111111111111111111111111101111 C
b11111111111111111111111111101111 N
b11111111111111111111111111101111 T
b11111111111111111111111111101111 c
b100000 .
b100000 s
b100000 v
b11 D
b11 P
b11 S
1<
0@
b10011101000100000001001010 B
b10011101000100000001001010 J
b10011101000100000001001010 _
b1000 1
b1000 ]
b1000 e
b1000 |
b1000 2
b1000 f
b1000 m
b1000 >
b1000 O
b1000 l
b0 %
b0 X
b0 b
b0 {
b0 #
b0 Y
b0 p
b0 y
b0 &
b0 L
b0 W
b0 $
b0 Z
b0 o
b100000 +
b100000 r
b100000 $"
b10 )
b10 R
b10 k
b1000 "
b1000 #"
b10011101000100000000101010 8
b10011101000100000000101010 H
b10011101000100000000101010 `
b10011101000100000000101010 i
b10011101000100000000101010 q
b1000000000000000000000001000 =
b1000000000000000000000001000 h
b1000000000000000000000001000 j
b1000000000000000000000001000 ""
b11100 -
b11100 g
b11100 !"
b11100 F
b11100 ~
1G
#8
13
bx ?
bx U
bx d
b10011101000100000000101010 /
b10011101000100000000101010 w
bx .
bx s
bx v
bx (
bx t
b10000000010101000 ,
b10000000010101000 I
b10000000010101000 ^
b111 E
b111 M
b111 Q
b0 C
b0 N
b0 T
b0 c
b10 D
b10 P
b10 S
14
0<
17
bx B
bx J
bx _
b1001110100010000000010101000 +
b1001110100010000000010101000 r
b1001110100010000000010101000 $"
b100000000101010 1
b100000000101010 ]
b100000000101010 e
b100000000101010 |
b100000000101010 2
b100000000101010 f
b100000000101010 m
b101010 >
b101010 O
b101010 l
b1000 '
b1000 [
b1000 n
b1000 x
b10100 %
b10100 X
b10100 b
b10100 {
b10100 #
b10100 Y
b10100 p
b10100 y
b10011 &
b10011 L
b10011 W
b10011 $
b10011 Z
b10011 o
b0 )
b0 R
b0 k
b10011101000100000000101010 "
b10011101000100000000101010 #"
bx 8
bx H
bx `
bx i
bx q
b10011101000100000000101010 =
b10011101000100000000101010 h
b10011101000100000000101010 j
b10011101000100000000101010 ""
b100000 -
b100000 g
b100000 !"
b100000 F
b100000 ~
0G
#9
1G
